<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎯 Sequence - Telegram Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        .game-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 15px;
        }

        .game-title {
            font-size: 1.8em;
            color: #ffd700;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .multiplayer-info {
            background: rgba(0, 136, 204, 0.2);
            border: 2px solid #0088cc;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 15px;
            text-align: center;
            color: #0088cc;
            font-weight: bold;
            font-size: 0.9em;
        }

        .session-info {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .session-info h3 {
            color: #ffc107;
            margin-bottom: 10px;
            text-align: center;
        }

        .session-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .session-details div {
            background: rgba(0,0,0,0.1);
            padding: 5px 8px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.8em;
        }

        .players-list {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .player-card {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            border: 2px solid transparent;
        }

        .player-card.current-turn {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .player-card.is-you {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .current-turn-indicator {
            background: #ffd700;
            color: #333;
            padding: 6px 12px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 0.8em;
        }

        .waiting-room {
            background: rgba(255, 152, 0, 0.2);
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            text-align: center;
        }

        .waiting-room h3 {
            color: #ff9800;
            margin-bottom: 15px;
        }

        .start-game-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }

        .board-container {
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            max-width: 100%;
            margin: 0 auto;
            aspect-ratio: 1;
        }

        .board-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.5em;
            font-weight: bold;
            color: #333;
            background: white;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            user-select: none;
        }

        .board-cell:active {
            transform: scale(0.95);
        }

        .board-cell.free {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            font-weight: bold;
        }

        .board-cell.occupied {
            border: 2px solid;
        }

        .board-cell.team-0 {
            background: #4285f4;
            color: white;
            border-color: #1565c0;
        }

        .board-cell.team-1 {
            background: #34a853;
            color: white;
            border-color: #2e7d32;
        }

        .board-cell.team-2 {
            background: #ea4335;
            color: white;
            border-color: #c62828;
        }

        .board-cell.selectable {
            animation: pulse 1.5s infinite;
            border-color: #ffd700 !important;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 3px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        .suit-spades { color: #000; }
        .suit-hearts { color: #e74c3c; }
        .suit-diamonds { color: #e74c3c; }
        .suit-clubs { color: #000; }

        .player-hand {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .hand-title {
            font-size: 1.1em;
            margin-bottom: 10px;
            text-align: center;
            color: #ffd700;
        }

        .hand-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }

        .card {
            width: 45px;
            height: 65px;
            background: white;
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            color: #333;
            position: relative;
            font-size: 0.8em;
            user-select: none;
        }

        .card:active {
            transform: scale(0.95);
        }

        .card.selected {
            border-color: #ffd700;
            background: #fffde7;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.5);
        }

        .card.dead {
            opacity: 0.5;
            background: #ffebee;
        }

        .actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background: #ffd700;
            color: #333;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .game-status {
            text-align: center;
            font-size: 1em;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .win-message {
            background: #ffd700;
            color: #333;
            font-size: 1.3em;
            font-weight: bold;
            animation: celebration 2s ease-in-out infinite;
        }

        @keyframes celebration {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .sync-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            z-index: 1000;
        }

        .sync-indicator.syncing {
            background: #ff9800;
            animation: blink 1s infinite;
        }

        .sync-indicator.error {
            background: #f44336;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            .board-cell {
                font-size: 0.4em;
            }
            
            .card {
                width: 40px;
                height: 55px;
                font-size: 0.7em;
            }
            
            .btn {
                padding: 8px 16px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="sync-indicator" id="syncIndicator"></div>
    
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">🎯 SEQUENCE</h1>
        </div>

        <div class="multiplayer-info">
            📱 Multiplayer Game | Session: <span id="sessionDisplay">Loading...</span>
        </div>

        <div class="session-info" id="sessionInfo">
            <h3>🔍 Session Info</h3>
            <div class="session-details">
                <div><strong>Session:</strong> <span id="debugSessionId">-</span></div>
                <div><strong>Your ID:</strong> <span id="debugUserId">-</span></div>
                <div><strong>Players:</strong> <span id="debugPlayerCount">-</span></div>
                <div><strong>Status:</strong> <span id="debugGameStatus">-</span></div>
            </div>
        </div>

        <div class="waiting-room" id="waitingRoom" style="display: none;">
            <h3>⏳ Waiting for Game to Start</h3>
            <p>Players will be dealt cards when the game begins.</p>
            <button class="start-game-btn" onclick="requestStartGame()" id="startGameBtn">Start Game</button>
        </div>

        <div class="players-list" id="playersList">
            <h3>👥 Players in Session</h3>
            <div class="players-grid" id="playersGrid"></div>
        </div>

        <div class="game-info" id="gameInfo" style="display: none;">
            <div class="player-info">
                <span id="sequenceCount">Sequences: 0/2</span>
            </div>
            <div class="current-turn-indicator" id="currentTurn">Waiting...</div>
            <div class="player-info">
                <span id="deckCount">Cards: 104</span>
            </div>
        </div>

        <div class="game-status" id="gameStatus">
            Loading game session...
        </div>

        <div class="board-container" id="boardContainer" style="display: none;">
            <div class="board" id="gameBoard"></div>
        </div>

        <div class="actions" id="gameActions" style="display: none;">
            <button class="btn btn-primary" onclick="playSelectedCard()" id="playBtn" disabled>Play Card</button>
            <button class="btn btn-secondary" onclick="exchangeDeadCard()" id="deadCardBtn" disabled>Exchange Dead</button>
        </div>

        <div class="player-hand" id="playerHand" style="display: none;">
            <div class="hand-title">Your Hand (<span id="handCount">0</span> cards)</div>
            <div class="hand-cards" id="handCards"></div>
        </div>
    </div>

    <!-- Telegram Games API -->
    <script src="https://telegram.org/js/games.js"></script>

    <script>
        // Telegram Games integration
        let telegramGameProxy = null;
        let gameParams = {};
        
        // Initialize Telegram Games
        if (typeof TelegramGameProxy !== 'undefined') {
            telegramGameProxy = TelegramGameProxy;
            gameParams = telegramGameProxy.initParams || {};
        }

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session_id') || 'demo';
        const userId = urlParams.get('user_id') || gameParams.user_id || Math.floor(Math.random() * 10000);
        const chatId = urlParams.get('chat_id') || gameParams.chat_id || 'demo';

        // CORRECT BOARD LAYOUT FOR SEQUENCE
        const BOARD_LAYOUT = [
            ['FREE', '2♠', '3♠', '4♠', '5♠', '6♠', '7♠', '8♠', '9♠', 'FREE'],
            ['6♣', '5♣', '4♣', '3♣', '2♣', 'A♥', 'K♥', 'Q♥', '10♥', '10♠'],
            ['7♣', 'A♠', '2♦', '3♦', '4♦', '5♦', '6♦', '7♦', '9♥', 'Q♠'],
            ['8♣', 'K♠', '6♣', '5♣', '4♣', '3♣', '2♣', '8♦', '8♥', 'K♠'],
            ['9♣', 'Q♠', '7♣', '6♥', '5♥', '4♥', 'A♥', '9♦', '7♥', 'A♠'],
            ['10♣', '10♠', '8♣', '7♥', '2♥', '3♥', 'K♥', '10♦', '6♥', '2♦'],
            ['Q♣', '9♠', '9♣', '8♥', '9♥', '10♥', 'Q♥', 'Q♦', '5♥', '3♦'],
            ['K♣', '8♠', '10♣', 'Q♣', 'K♣', 'A♣', 'A♦', 'K♦', '4♥', '4♦'],
            ['A♣', '7♠', '6♠', '5♠', '4♠', '3♠', '2♠', '2♥', '3♥', '5♦'],
            ['FREE', 'A♦', 'K♦', 'Q♦', '10♦', '9♦', '8♦', '7♦', '6♦', 'FREE']
        ];

        // Global game state
        let gameState = {
            sessionId: sessionId,
            userId: userId,
            chatId: chatId,
            players: [],
            myPlayerIndex: -1,
            gameStarted: false,
            currentPlayerIndex: 0,
            board: [],
            myHand: [],
            selectedCard: null,
            sequences: 0,
            gameOver: false,
            lastSync: 0
        };

        // Simulated multiplayer state stored in memory
        let multiplayerState = {};

        // Initialize game
        function initGame() {
            updateDebugInfo();
            
            // Initialize multiplayer session
            if (!multiplayerState[sessionId]) {
                createMultiplayerSession();
            }
            
            // Add this player to session
            addPlayerToSession();
            
            // Create board
            createBoard();
            
            // Start sync loop
            setInterval(syncGameState, 1000);
            
            // Initial render
            renderGame();
            
            console.log('Game initialized for session:', sessionId);
        }

        function createMultiplayerSession() {
            multiplayerState[sessionId] = {
                players: [],
                gameStarted: false,
                currentPlayerIndex: 0,
                board: [],
                deck: createShuffledDeck(),
                hands: {},
                sequences: {},
                gameOver: false,
                winner: null,
                createdAt: Date.now()
            };
            
            // Initialize board
            const board = [];
            for (let row = 0; row < 10; row++) {
                board[row] = [];
                for (let col = 0; col < 10; col++) {
                    board[row][col] = {
                        card: BOARD_LAYOUT[row][col],
                        occupied: false,
                        team: null,
                        isFree: BOARD_LAYOUT[row][col] === 'FREE'
                    };
                }
            }
            multiplayerState[sessionId].board = board;
            
            console.log('Created new multiplayer session:', sessionId);
        }

        function createShuffledDeck() {
            const suits = ['♠', '♥', '♦', '♣'];
            const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            
            const deck = [];
            // Create exactly 2 of each card (104 cards total) - proper Sequence deck
            for (let i = 0; i < 2; i++) {
                for (const suit of suits) {
                    for (const value of values) {
                        deck.push(`${value}${suit}`);
                    }
                }
            }
            
            // Shuffle the deck
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            
            return deck;
        }

        function addPlayerToSession() {
            const session = multiplayerState[sessionId];
            
            // Check if player already exists
            const existingPlayerIndex = session.players.findIndex(p => p.id === userId);
            if (existingPlayerIndex !== -1) {
                gameState.myPlayerIndex = existingPlayerIndex;
                console.log('Player reconnected to session');
                return;
            }
            
            // Add new player
            const playerNumber = session.players.length + 1;
            const newPlayer = {
                id: userId,
                name: `Player ${playerNumber}`,
                team: Math.floor(session.players.length / 2), // Simple team assignment
                joinedAt: Date.now()
            };
            
            session.players.push(newPlayer);
            gameState.myPlayerIndex = session.players.length - 1;
            
            // Initialize sequences counter
            session.sequences[userId] = 0;
            
            console.log('Player added to session:', newPlayer);
        }

        function startMultiplayerGame() {
            const session = multiplayerState[sessionId];
            
            if (session.gameStarted) {
                updateGameStatus('Game already started!');
                return false;
            }
            
            if (session.players.length < 2) {
                updateGameStatus('Need at least 2 players to start!');
                return false;
            }
            
            // Deal cards to all players
            const cardsPerPlayer = getCardsPerPlayer(session.players.length);
            
            for (const player of session.players) {
                const hand = [];
                for (let i = 0; i < cardsPerPlayer; i++) {
                    if (session.deck.length > 0) {
                        hand.push(session.deck.pop());
                    }
                }
                session.hands[player.id] = hand;
            }
            
            session.gameStarted = true;
            session.currentPlayerIndex = 0;
            
            console.log('Multiplayer game started with', session.players.length, 'players');
            return true;
        }

        function getCardsPerPlayer(playerCount) {
            const cardDistribution = {
                2: 7, 3: 6, 4: 6, 5: 5, 6: 5
            };
            return cardDistribution[playerCount] || 5;
        }

        function syncGameState() {
            const session = multiplayerState[sessionId];
            if (!session) return;
            
            // Update local game state from multiplayer session
            gameState.players = session.players;
            gameState.gameStarted = session.gameStarted;
            gameState.currentPlayerIndex = session.currentPlayerIndex;
            gameState.board = session.board;
            gameState.myHand = session.hands[userId] || [];
            gameState.gameOver = session.gameOver;
            gameState.lastSync = Date.now();
            
            // Update UI
            renderGame();
            updateSyncIndicator(true);
        }

        function createBoard() {
            gameState.board = [];
            for (let row = 0; row < 10; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < 10; col++) {
                    gameState.board[row][col] = {
                        card: BOARD_LAYOUT[row][col],
                        occupied: false,
                        team: null,
                        isFree: BOARD_LAYOUT[row][col] === 'FREE'
                    };
                }
            }
        }

        function renderGame() {
            renderSessionInfo();
            renderPlayersList();
            renderGameInterface();
            updateDebugInfo();
        }

        function renderSessionInfo() {
            const session = multiplayerState[sessionId];
            if (!session) return;
            
            document.getElementById('sessionDisplay').textContent = sessionId.substring(0, 12) + '...';
            document.getElementById('debugSessionId').textContent = sessionId.substring(0, 20) + '...';
            document.getElementById('debugUserId').textContent = userId;
            document.getElementById('debugPlayerCount').textContent = session.players.length;
            document.getElementById('debugGameStatus').textContent = session.gameStarted ? 'Playing' : 'Waiting';
        }

        function renderPlayersList() {
            const session = multiplayerState[sessionId];
            if (!session) return;
            
            const playersGrid = document.getElementById('playersGrid');
            playersGrid.innerHTML = '';
            
            session.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                if (player.id === userId) {
                    playerCard.classList.add('is-you');
                }
                
                if (session.gameStarted && index === session.currentPlayerIndex) {
                    playerCard.classList.add('current-turn');
                }
                
                const handSize = session.hands[player.id] ? session.hands[player.id].length : 0;
                const sequences = session.sequences[player.id] || 0;
                
                playerCard.innerHTML = `
                    <div><strong>${player.name}</strong></div>
                    <div>${player.id === userId ? '(You)' : ''}</div>
                    <div>Team ${player.team + 1}</div>
                    <div>Cards: ${handSize}</div>
                    <div>Sequences: ${sequences}</div>
                `;
                
                playersGrid.appendChild(playerCard);
            });
        }

        function renderGameInterface() {
            const session = multiplayerState[sessionId];
            if (!session) return;
            
            const waitingRoom = document.getElementById('waitingRoom');
            const gameInfo = document.getElementById('gameInfo');
            const boardContainer = document.getElementById('boardContainer');
            const gameActions = document.getElementById('gameActions');
            const playerHand = document.getElementById('playerHand');
            
            if (!session.gameStarted) {
                // Show waiting room
                waitingRoom.style.display = 'block';
                gameInfo.style.display = 'none';
                boardContainer.style.display = 'none';
                gameActions.style.display = 'none';
                playerHand.style.display = 'none';
                
                // Only first player can start the game
                const startBtn = document.getElementById('startGameBtn');
                startBtn.disabled = session.players[0].id !== userId || session.players.length < 2;
                
                updateGameStatus(`Waiting for ${Math.max(2 - session.players.length, 0)} more players...`);
            } else {
                // Show game interface
                waitingRoom.style.display = 'none';
                gameInfo.style.display = 'flex';
                boardContainer.style.display = 'block';
                gameActions.style.display = 'flex';
                playerHand.style.display = 'block';
                
                renderBoard();
                renderHand();
                updateGameInfo();
            }
        }

        function renderBoard() {
            const boardElement = document.getElementById('gameBoard');
            boardElement.innerHTML = '';

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = gameState.board[row][col];
                    const cellElement = document.createElement('div');
                    cellElement.className = 'board-cell';
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;

                    if (cell.isFree) {
                        cellElement.classList.add('free');
                        cellElement.innerHTML = '<div style="font-size: 0.6em;">FREE</div>';
                    } else {
                        const [value, suit] = parseCard(cell.card);
                        cellElement.innerHTML = `
                            <div class="card-suit ${getSuitClass(suit)}">${suit}</div>
                            <div class="card-value">${value}</div>
                        `;
                    }

                    if (cell.occupied) {
                        cellElement.classList.add('occupied', `team-${cell.team}`);
                    }

                    cellElement.addEventListener('click', () => handleBoardClick(row, col));

                    if (gameState.selectedCard && canPlaceCard(gameState.selectedCard, row, col)) {
                        cellElement.classList.add('selectable');
                    }

                    boardElement.appendChild(cellElement);
                }
            }
        }

        function renderHand() {
            const handElement = document.getElementById('handCards');
            handElement.innerHTML = '';

            gameState.myHand.forEach((card, index) => {
                const cardElement = createCardElement(card, index);
                handElement.appendChild(cardElement);
            });

            document.getElementById('handCount').textContent = gameState.myHand.length;
        }

        function createCardElement(card, cardIndex) {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            cardElement.dataset.cardIndex = cardIndex;
            cardElement.dataset.card = card;

            const [value, suit] = parseCard(card);
            
            cardElement.innerHTML = `
                <div class="card-value">${value}</div>
                <div class="card-suit-symbol ${getSuitClass(suit)}">${suit}</div>
            `;

            if (isDeadCard(card)) {
                cardElement.classList.add('dead');
                cardElement.title = 'Dead card - both positions occupied';
            }

            cardElement.addEventListener('click', () => handleCardClick(cardIndex, card));

            if (gameState.selectedCard === card) {
                cardElement.classList.add('selected');
            }

            return cardElement;
        }

        function handleCardClick(cardIndex, card) {
            if (gameState.gameOver) return;
            if (!isMyTurn()) {
                updateGameStatus('Not your turn!');
                return;
            }

            if (gameState.selectedCard === card) {
                gameState.selectedCard = null;
                updateGameStatus('Card deselected. Choose a card to play.');
                document.getElementById('playBtn').disabled = true;
            } else {
                gameState.selectedCard = card;
                document.getElementById('playBtn').disabled = false;
                
                if (isJack(card)) {
                    const jackType = isOneEyedJack(card) ? 'remove an opponent\'s chip' : 'place a chip anywhere';
                    updateGameStatus(`Selected ${card} - Tap on the board to ${jackType}`);
                } else if (isDeadCard(card)) {
                    updateGameStatus(`Selected dead card ${card} - Use "Exchange Dead" button`);
                    document.getElementById('deadCardBtn').disabled = false;
                } else {
                    updateGameStatus(`Selected ${card} - Tap on a matching position on the board`);
                }
            }

            renderGame();
        }

        function handleBoardClick(row, col) {
            if (gameState.gameOver) return;
            if (!isMyTurn()) {
                updateGameStatus('Not your turn!');
                return;
            }
            if (!gameState.selectedCard) {
                updateGameStatus('Please select a card from your hand first!');
                return;
            }

            const cell = gameState.board[row][col];
            const card = gameState.selectedCard;

            if (isJack(card)) {
                handleJackPlay(row, col);
            } else {
                handleRegularCardPlay(row, col);
            }
        }

        function handleJackPlay(row, col) {
            const cell = gameState.board[row][col];
            const card = gameState.selectedCard;

            if (isOneEyedJack(card)) {
                if (cell.occupied && cell.team !== gameState.players[gameState.myPlayerIndex].team && !cell.isFree) {
                    playCardOnBoard(row, col);
                } else {
                    updateGameStatus('Cannot remove chip from this position!');
                }
            } else {
                if (!cell.occupied) {
                    playCardOnBoard(row, col);
                } else {
                    updateGameStatus('Position already occupied!');
                }
            }
        }

        function handleRegularCardPlay(row, col) {
            const cell = gameState.board[row][col];
            const card = gameState.selectedCard;

            if (cell.card === card && !cell.occupied) {
                playCardOnBoard(row, col);
            } else if (cell.card !== card) {
                updateGameStatus('Card doesn\'t match this board position!');
            } else {
                updateGameStatus('Position already occupied!');
            }
        }

        function playCardOnBoard(row, col) {
            const session = multiplayerState[sessionId];
            const cell = session.board[row][col];
            const card = gameState.selectedCard;
            const myTeam = gameState.players[gameState.myPlayerIndex].team;

            if (isJack(card)) {
                if (isOneEyedJack(card)) {
                    // Remove opponent's chip
                    cell.occupied = false;
                    cell.team = null;
                } else {
                    // Place chip anywhere
                    cell.occupied = true;
                    cell.team = myTeam;
                }
            } else {
                // Regular card play
                cell.occupied = true;
                cell.team = myTeam;
            }

            // Remove card from hand
            const cardIndex = session.hands[userId].indexOf(card);
            session.hands[userId].splice(cardIndex, 1);

            // Draw new card if deck has cards
            if (session.deck.length > 0) {
                session.hands[userId].push(session.deck.pop());
            }

            gameState.selectedCard = null;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('deadCardBtn').disabled = true;

            // Check for sequences
            checkSequences();

            // Next player's turn
            session.currentPlayerIndex = (session.currentPlayerIndex + 1) % session.players.length;

            updateGameStatus('Card played! Checking for sequences...');
            setTimeout(() => {
                if (!gameState.gameOver) {
                    const currentPlayer = session.players[session.currentPlayerIndex];
                    if (currentPlayer.id === userId) {
                        updateGameStatus('Your turn! Select a card to play.');
                    } else {
                        updateGameStatus(`${currentPlayer.name}'s turn`);
                    }
                }
            }, 1500);
        }

        function playSelectedCard() {
            if (!gameState.selectedCard) {
                updateGameStatus('Please select a card first!');
                return;
            }
            
            updateGameStatus('Selected card. Now click on the board to place it!');
        }

        function exchangeDeadCard() {
            const session = multiplayerState[sessionId];
            
            if (!gameState.selectedCard || !isDeadCard(gameState.selectedCard)) {
                updateGameStatus('Please select a dead card first!');
                return;
            }

            if (!isMyTurn()) {
                updateGameStatus('Not your turn!');
                return;
            }

            const cardIndex = session.hands[userId].indexOf(gameState.selectedCard);
            session.hands[userId].splice(cardIndex, 1);
            
            // Draw new card if available
            if (session.deck.length > 0) {
                session.hands[userId].push(session.deck.pop());
            }

            gameState.selectedCard = null;
            document.getElementById('deadCardBtn').disabled = true;
            document.getElementById('playBtn').disabled = true;

            // Next player's turn
            session.currentPlayerIndex = (session.currentPlayerIndex + 1) % session.players.length;

            updateGameStatus('Dead card exchanged!');
        }

        function checkSequences() {
            const session = multiplayerState[sessionId];
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            
            // Reset sequence counts
            for (const player of session.players) {
                session.sequences[player.id] = 0;
            }

            // Check for sequences
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    for (let [dx, dy] of directions) {
                        const sequenceTeam = checkSequenceFromPosition(row, col, dx, dy);
                        if (sequenceTeam !== null) {
                            // Add sequence to all players in this team
                            for (const player of session.players) {
                                if (player.team === sequenceTeam) {
                                    session.sequences[player.id]++;
                                }
                            }
                        }
                    }
                }
            }

            // Check for winner (2 sequences needed)
            for (const player of session.players) {
                if (session.sequences[player.id] >= 2) {
                    session.gameOver = true;
                    session.winner = player.id;
                    
                    if (player.id === userId) {
                        updateGameStatus('🎉 You Win! 🎉 You completed 2 sequences!');
                        document.getElementById('gameStatus').classList.add('win-message');
                    } else {
                        updateGameStatus(`🎉 ${player.name} Wins! 🎉 Game Over!`);
                    }
                    break;
                }
            }
        }

        function checkSequenceFromPosition(startRow, startCol, dx, dy) {
            const session = multiplayerState[sessionId];
            const positions = [];
            let row = startRow;
            let col = startCol;

            // Collect 5 positions
            for (let i = 0; i < 5; i++) {
                if (row < 0 || row >= 10 || col < 0 || col >= 10) return null;
                positions.push([row, col]);
                row += dx;
                col += dy;
            }

            // Check if all positions belong to same team
            let team = null;
            for (let [r, c] of positions) {
                const cell = session.board[r][c];
                if (cell.isFree) continue; // Free corners can be used by any team
                if (!cell.occupied) return null;
                if (team === null) {
                    team = cell.team;
                } else if (cell.team !== team) {
                    return null;
                }
            }

            return team;
        }

        function requestStartGame() {
            if (startMultiplayerGame()) {
                updateGameStatus('Game started! Cards dealt to all players.');
            }
        }

        function updateGameInfo() {
            const session = multiplayerState[sessionId];
            if (!session) return;
            
            const mySequences = session.sequences[userId] || 0;
            document.getElementById('sequenceCount').textContent = `Sequences: ${mySequences}/2`;
            document.getElementById('deckCount').textContent = `Cards: ${session.deck.length}`;
            
            const currentPlayer = session.players[session.currentPlayerIndex];
            if (currentPlayer) {
                if (currentPlayer.id === userId) {
                    document.getElementById('currentTurn').textContent = 'Your Turn';
                    document.getElementById('currentTurn').style.background = '#4caf50';
                } else {
                    document.getElementById('currentTurn').textContent = `${currentPlayer.name}'s Turn`;
                    document.getElementById('currentTurn').style.background = '#ff9800';
                }
            }
        }

        function updateDebugInfo() {
            // Update debug information displays
            renderSessionInfo();
        }

        function updateGameStatus(message) {
            document.getElementById('gameStatus').textContent = message;
        }

        function updateSyncIndicator(success) {
            const indicator = document.getElementById('syncIndicator');
            if (success) {
                indicator.className = 'sync-indicator';
            } else {
                indicator.className = 'sync-indicator error';
            }
        }

        function isMyTurn() {
            const session = multiplayerState[sessionId];
            if (!session || !session.gameStarted) return false;
            
            const currentPlayer = session.players[session.currentPlayerIndex];
            return currentPlayer && currentPlayer.id === userId;
        }

        // Helper functions
        function parseCard(card) {
            if (card === 'FREE') return ['FREE', ''];
            const suit = card.slice(-1);
            const value = card.slice(0, -1);
            return [value, suit];
        }

        function getSuitClass(suit) {
            const suitClasses = {
                '♠': 'suit-spades',
                '♥': 'suit-hearts',
                '♦': 'suit-diamonds',
                '♣': 'suit-clubs'
            };
            return suitClasses[suit] || '';
        }

        function isJack(card) {
            return card.startsWith('J');
        }

        function isOneEyedJack(card) {
            return card === 'J♠' || card === 'J♥';
        }

        function isDeadCard(card) {
            if (isJack(card)) return false;
            
            const positions = findCardPositions(card);
            return positions.length > 0 && positions.every(([row, col]) => gameState.board[row][col].occupied);
        }

        function findCardPositions(card) {
            const positions = [];
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    if (gameState.board[row][col].card === card) {
                        positions.push([row, col]);
                    }
                }
            }
            return positions;
        }

        function canPlaceCard(card, row, col) {
            const cell = gameState.board[row][col];
            const myTeam = gameState.players[gameState.myPlayerIndex]?.team;
            
            if (isJack(card)) {
                if (isOneEyedJack(card)) {
                    return cell.occupied && cell.team !== myTeam && !cell.isFree;
                } else {
                    return !cell.occupied;
                }
            } else {
                return cell.card === card && !cell.occupied;
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Sequence Game Loading...');
            console.log('Session ID:', sessionId);
            console.log('User ID:', userId);
            console.log('Chat ID:', chatId);
            
            initGame();
        });

        // Cleanup when page unloads
        window.addEventListener('beforeunload', () => {
            console.log('Game session ending for user:', userId);
        });
    </script>
</body>
</html>
